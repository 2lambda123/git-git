gc.aggressiveDepth::
	The depth parameter used in the delta compression
	algorithm used by 'but gc --aggressive'.  This defaults
	to 50, which is the default for the `--depth` option when
	`--aggressive` isn't in use.
+
See the documentation for the `--depth` option in
linkbut:but-repack[1] for more details.

gc.aggressiveWindow::
	The window size parameter used in the delta compression
	algorithm used by 'but gc --aggressive'.  This defaults
	to 250, which is a much more aggressive window size than
	the default `--window` of 10.
+
See the documentation for the `--window` option in
linkbut:but-repack[1] for more details.

gc.auto::
	When there are approximately more than this many loose
	objects in the repository, `but gc --auto` will pack them.
	Some Porcelain commands use this command to perform a
	light-weight garbage collection from time to time.  The
	default value is 6700.
+
Setting this to 0 disables not only automatic packing based on the
number of loose objects, but any other heuristic `but gc --auto` will
otherwise use to determine if there's work to do, such as
`gc.autoPackLimit`.

gc.autoPackLimit::
	When there are more than this many packs that are not
	marked with `*.keep` file in the repository, `but gc
	--auto` consolidates them into one larger pack.  The
	default value is 50.  Setting this to 0 disables it.
	Setting `gc.auto` to 0 will also disable this.
+
See the `gc.bigPackThreshold` configuration variable below. When in
use, it'll affect how the auto pack limit works.

gc.autoDetach::
	Make `but gc --auto` return immediately and run in background
	if the system supports it. Default is true.

gc.bigPackThreshold::
	If non-zero, all packs larger than this limit are kept when
	`but gc` is run. This is very similar to `--keep-largest-pack`
	except that all packs that meet the threshold are kept, not
	just the largest pack. Defaults to zero. Common unit suffixes of
	'k', 'm', or 'g' are supported.
+
Note that if the number of kept packs is more than gc.autoPackLimit,
this configuration variable is ignored, all packs except the base pack
will be repacked. After this the number of packs should go below
gc.autoPackLimit and gc.bigPackThreshold should be respected again.
+
If the amount of memory estimated for `but repack` to run smoothly is
not available and `gc.bigPackThreshold` is not set, the largest pack
will also be excluded (this is the equivalent of running `but gc` with
`--keep-largest-pack`).

gc.writecummitGraph::
	If true, then gc will rewrite the cummit-graph file when
	linkbut:but-gc[1] is run. When using `but gc --auto`
	the cummit-graph will be updated if housekeeping is
	required. Default is true. See linkbut:but-cummit-graph[1]
	for details.

gc.logExpiry::
	If the file gc.log exists, then `but gc --auto` will print
	its content and exit with status zero instead of running
	unless that file is more than 'gc.logExpiry' old.  Default is
	"1.day".  See `gc.pruneExpire` for more ways to specify its
	value.

gc.packRefs::
	Running `but pack-refs` in a repository renders it
	unclonable by Git versions prior to 1.5.1.2 over dumb
	transports such as HTTP.  This variable determines whether
	'but gc' runs `but pack-refs`. This can be set to `notbare`
	to enable it within all non-bare repos or it can be set to a
	boolean value.  The default is `true`.

gc.pruneExpire::
	When 'but gc' is run, it will call 'prune --expire 2.weeks.ago'.
	Override the grace period with this config variable.  The value
	"now" may be used to disable this grace period and always prune
	unreachable objects immediately, or "never" may be used to
	suppress pruning.  This feature helps prevent corruption when
	'but gc' runs concurrently with another process writing to the
	repository; see the "NOTES" section of linkbut:but-gc[1].

gc.worktreePruneExpire::
	When 'but gc' is run, it calls
	'but worktree prune --expire 3.months.ago'.
	This config variable can be used to set a different grace
	period. The value "now" may be used to disable the grace
	period and prune `$GIT_DIR/worktrees` immediately, or "never"
	may be used to suppress pruning.

gc.reflogExpire::
gc.<pattern>.reflogExpire::
	'but reflog expire' removes reflog entries older than
	this time; defaults to 90 days. The value "now" expires all
	entries immediately, and "never" suppresses expiration
	altogether. With "<pattern>" (e.g.
	"refs/stash") in the middle the setting applies only to
	the refs that match the <pattern>.

gc.reflogExpireUnreachable::
gc.<pattern>.reflogExpireUnreachable::
	'but reflog expire' removes reflog entries older than
	this time and are not reachable from the current tip;
	defaults to 30 days. The value "now" expires all entries
	immediately, and "never" suppresses expiration altogether.
	With "<pattern>" (e.g. "refs/stash")
	in the middle, the setting applies only to the refs that
	match the <pattern>.
+
These types of entries are generally created as a result of using `but
cummit --amend` or `but rebase` and are the cummits prior to the amend
or rebase occurring.  Since these changes are not part of the current
project most users will want to expire them sooner, which is why the
default is more aggressive than `gc.reflogExpire`.

gc.rerereResolved::
	Records of conflicted merge you resolved earlier are
	kept for this many days when 'but rerere gc' is run.
	You can also use more human-readable "1.month.ago", etc.
	The default is 60 days.  See linkbut:but-rerere[1].

gc.rerereUnresolved::
	Records of conflicted merge you have not resolved are
	kept for this many days when 'but rerere gc' is run.
	You can also use more human-readable "1.month.ago", etc.
	The default is 15 days.  See linkbut:but-rerere[1].
